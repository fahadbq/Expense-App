import { createAsyncThunk, createSlice, PayloadAction } from "@reduxjs/toolkit";
import { RootState, AppThunk } from "../../app/store/store";
import { api } from "../../app/services/api";

export const createBudget = createAsyncThunk(
  "settingsSlice/createBudget",
  (data: object) => {
    return api.settingsAdministration.createBudget(data);
  }
);

export const updateBudget = createAsyncThunk(
  "settingsSlice/updateBudget",
  (data: object) => {
    return api.settingsAdministration.updateBudget(data);
  }
);

export const getBudget = createAsyncThunk("settingsSlice/getBudget", () => {
  return api.settingsAdministration.getBudget();
});

export const createCategory = createAsyncThunk(
  "settingsSlice/createCategory",
  (data: object) => {
    return api.settingsAdministration.createCategory(data);
  }
);

export const getCategories = createAsyncThunk(
  "settingsSlice/getCategories",
  () => {
    return api.homeAdministration.getCategories();
  }
);

export const updateCategory = createAsyncThunk(
  "settingsSlice/updateCategory",
  (data: object) => {
    return api.settingsAdministration.updateCategory(data);
  }
);

export const deleteCategory = createAsyncThunk(
  "settingsSlice/deleteCategory",
  (id: string) => {
    return api.settingsAdministration.deleteCategory(id);
  }
);

//Transform Data
const transformCategories = (rawData: object[]) => {
  const filterUncategorized = rawData.filter((ele: any) => {
    return ele.name !== "Uncategorised";
  });

  const result = filterUncategorized.map((obj: any) => {
    return {
      ...obj,
      value: obj._id,
      label: obj.name,
    };
  });
  return result;
};

export interface HomeState {
  budgetError: string | undefined;

  updateBudgetError: string | undefined;

  budgetLoading: boolean | undefined;
  budgetData: object | undefined;

  categoryError: string | undefined;

  categoriesLoading: boolean | undefined;
  categoriesData: object[] | undefined;
  categoriesError: string | undefined;

  categoriesUpdateLoading: boolean | undefined;
  categoriesUpdateError: string | undefined;

  deleteCategoriesLoading: boolean | undefined;
}

const initialState: HomeState = {
  budgetError: "",

  updateBudgetError: "",

  budgetLoading: false,
  budgetData: [],

  categoryError: "",

  categoriesLoading: false,
  categoriesData: [],
  categoriesError: "",

  categoriesUpdateLoading: false,
  categoriesUpdateError: "",

  deleteCategoriesLoading: false,
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
// export const incrementAsync = createAsyncThunk(
//   'counter/fetchCount',
//   async (amount: number) => {
//     const response = await fetchCount(amount);
//     // The value we return becomes the `fulfilled` action payload
//     return response.data;
//   }
// );

export const settingsSlice = createSlice({
  name: "settingsSlice",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {},
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.

  extraReducers: (builder) => {
    builder

      .addCase(createBudget.pending, (state) => {
        state.budgetError = "";
      })
      .addCase(createBudget.fulfilled, (state, action) => {
        state.budgetError = "";
      })
      .addCase(createBudget.rejected, (state, action) => {
        state.budgetError = action.error.message;
      })

      //Update Budget

      .addCase(updateBudget.pending, (state) => {
        state.updateBudgetError = "";
      })
      .addCase(updateBudget.fulfilled, (state, action) => {
        state.updateBudgetError = "";
      })
      .addCase(updateBudget.rejected, (state, action) => {
        state.updateBudgetError = action.error.message;
      })

      //Get Budget
      .addCase(getBudget.pending, (state) => {
        state.budgetLoading = false;
        state.budgetData = [];
      })
      .addCase(getBudget.fulfilled, (state, action) => {
        state.budgetLoading = true;
        state.budgetData = action.payload;
      })
      .addCase(getBudget.rejected, (state, action) => {
        state.budgetLoading = false;
        state.budgetData = [];
      })

      // Create Category

      .addCase(createCategory.pending, (state) => {
        state.categoryError = "";
      })
      .addCase(createCategory.fulfilled, (state, action) => {
        state.categoryError = "";
      })
      .addCase(createCategory.rejected, (state, action) => {
        state.categoryError = action.error?.message;
      })

      //Get Categories
      .addCase(getCategories.pending, (state) => {
        state.categoriesLoading = false;
        state.categoriesData = [];
        state.categoriesError = "";
      })
      .addCase(getCategories.fulfilled, (state, action) => {
        state.categoriesData = action.payload?.data?.reverse() || [];
      })
      .addCase(getCategories.rejected, (state, action) => {
        state.categoriesLoading = false;
        state.categoriesData = [];
        state.categoriesError = action.error?.message;
      })

      //Update Categories
      .addCase(updateCategory.pending, (state) => {
        state.categoriesUpdateLoading = true;
        state.categoriesUpdateError = "";
      })
      .addCase(updateCategory.fulfilled, (state, action) => {
        state.categoriesUpdateLoading = false;
        state.categoriesUpdateError = "";
      })
      .addCase(updateCategory.rejected, (state, action) => {
        state.categoriesUpdateLoading = false;
        state.categoriesUpdateError = action.error.message;
      })

      //Get Categories
      .addCase(deleteCategory.pending, (state) => {
        state.deleteCategoriesLoading = true;
      })
      .addCase(deleteCategory.fulfilled, (state, action) => {
        state.deleteCategoriesLoading = false;
      })
      .addCase(deleteCategory.rejected, (state, action) => {
        state.deleteCategoriesLoading = false;
      });
  },
});

// export const { increment, decrement, incrementByAmount } = userAuthSlice.actions;

// We can also write thunks by hand, which may contain both sync and async logic.
// Here's an example of conditionally dispatching actions based on current state

export default settingsSlice.reducer;
